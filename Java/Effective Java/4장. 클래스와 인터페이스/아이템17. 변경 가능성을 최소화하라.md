# 아이템 17. 변경 가능성을 최소화하라

---

## 불변 클래스

---

불변 클래스란 **그 인스턴스의 내부 값을 수정할 수 없는 클래스**다.  
불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.  
**불변 클래스를 사용하는 이유는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.**

### 불변 클래스 생성 규칙

- **객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.**
- **클래스를 확장할 수 없도록 한다.**
  - 하위 클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아준다.
- **모든 필드를 final로 선언한다.**
  - 시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법이다.
- **모든 필드를 private으로 선언한다.**
  - 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다.
- **자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.**
  - 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다.

### 불변 객체 장점

- **불변 객체는 단순하다.**
  - 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다.
- **불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다.**
  - 불변 객체에 대해서는 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 **불변 객체는 안심하고 공유할 수 있다.**
  - 따라서 불변 클래스라면 한번 만든 인스턴스를 **최대한 재활용하기를 권한다.**
```java
public static final Complex ZERO = new Complex(0, 0);
public static final Complex ONE = new Complex(1, 0);
public static final Complex I = new Complex(0, 1);
```
- **불변 객체는 자유롭게 공유할 수 있으므로 방어적 복사가 필요 없다.**
  - 복사 자체가 의미가 없기 때문에 `clone` 메서드나 복사 생성자를 제공하지 않는 게 좋다.
- **불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.**
- **객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.**
  - 값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 그 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월하기 때문이다.
  - 맵이나 집합은 안에 담긴 값이 바뀌면 불변식이 허물어지는데, 불변 객체를 사용하면 그런 걱정은 하지 않아도 된다.
- **불변 객체는 그 자체로 실패 원자성을 제공한다.**
  - 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다.

### 불변 객체 단점

- **값이 다르면 반드시 독립된 객체로 만들어야 한다.**
  - 값의 가짓수가 많다면 이들을 모두 만드는 데 큰 비용을 치러야 한다. 

### 불변 클래스 만드는 방법

클래스가 불변임을 보장하려면 자신을 상속하지 못하게 해야 한다고 했다.  
자신을 상속하지 못하게 하는 가장 쉬운 방법은 `final` 클래스로 선언하는 것이지만, 더 유연한 방법이 있다.

모든 생성자를 `private` 혹은 `package-private`으로 만들고 `public` 정적 팩터리를 제공하는 방법이다.

```java
public class Complex {
    private final double re;
    private final double im;
    
    private Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }
    
    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    }
    
    ...
}
```

`public`이나 `protected` 생성자가 없으니 다른 패키지에서는 이 클래스를 확장하는 게 불가능하기 때문에 사실상 `final`이다.  

정적 팩터리 방식은 다수의 구현 클래스를 활용한 유연성을 제공하고, 이에 더해 다음 릴리스에서 객체 캐싱 기능을 추가해 성능을 끌어올릴 수도 있다.

## 핵심 정리

---

- 게터(getter)가 있다고 해서 무조건 세터(setter)를 만들지는 말자.
- **클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.**
  - 불변 클래스는 장점이 많으며, 단점이라곤 특정 상황에서의 잠재적 성능 저하뿐이다.
  - 단순한 값 객체는 항상 불변으로 만들고, 무거운 값 객체도 불변으로 만들 수 있는지 고심해야 한다.
- **불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.**
  - 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
  - 그러니 꼭 변경해야 할 필드를 뺀 나머지 모두를 `final`로 선언하자.
- **다른 합당한 이유가 없다면 모든 필드는 `private final`이어야 한다.**
- **생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.**
