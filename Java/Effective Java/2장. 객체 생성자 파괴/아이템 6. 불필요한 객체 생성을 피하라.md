# 아이템 6. 불필요한 객체 생성을 피하라

---

똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다.  
재사용은 빠르고 세련되며, 특히 불변 객체는 언제든 재사용할 수 있다.

## 극단적인 예

---

```java
String s = new String("Java");  //따라 하지 말 것!
```

이 문장은 실행될 때마다 String 인스턴스를 새로 만들기 때문에 완전히 쓸데없는 행위다.

### 개선된 버전

```java
String s = "Java";
```

이 코드는 새로운 인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 사용한다.  
같은 가상 머신 안에서 **이와 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장된다.**

## 정적 팩터리 메서드

---

생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스에서는 **정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.**
- 생성자는 호출할 때마다 새로운 객체를 만든다.
- 예) `Boolean(String)` 생성자 대신 `Boolean.valueOf(String)` 팩터리 메서드를 사용하는 것이 좋다.

## 생성 비용이 비싼 객체

---

생성 비용이 비싼 객체가 반복해서 필요하다면 **캐싱하여 재사용하길 권한다.**

```java
static boolean isRomanNumeral(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0, 3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
    }
```

`String.matches`는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다.
- `String.matches` 내부에서 만드는 정규표현식용 Pattern 인스턴스는, 한 번 쓰고 버려져서 곧바로 가비지 컬렉션 대상이 된다.
- Pattern은 입력받은 정규표현식에 해당하는 유한 상태 머신을 만들기 때문에 인스턴스 생성 비용이 비싸다.

```java
public class RomanNumerals {
    private static final Pattern ROMAN = Pattern.compile(
        "^(?=.)M*(C[MD]|D?C{0, 3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$"
    );
    
    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).mathces();
    }
}
```

성능을 개선하려면 Pattern 인스턴스를 생성하여 재사용한다.
- `isRomanNumeral`이 빈번히 호출되는 상황에서 성능을 상당히 끌어올릴 수 있다.
- 하지만 `isRomanNumeral` 메서드가 한 번도 호출되지 않는다면 `ROMAN` 필드는 쓸데없이 초기화된 꼴이다.
- 메서드가 처음 호출될 때 필드를 초기화하는 **지연 초기화**로 불필요한 초기화를 없앨 수는 있지만, 권하지는 않는다.

## 오토박싱

---

불필요한 객체를 만들어내는 오토박싱이 있다.  
오토박싱은 프로그래머가 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술이다.

```java
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    return sum;
}
```

`sum` 변수를 long이 아닌 Long으로 선언해서 **불필요한 Long 인스턴스가 약 2^31개나 만들어진 것이다!**

**의도치 않은 오토박싱을 피하기 위해 박싱된 기본 타입보다는 기본 타입을 사용하자.**

## 객체를 생성하는 것이 나은 경우

---

데이터베이스 연결 같은 경우에는 생성 비용이 워낙 비싸니 재사용하는 편이 낫다.

방어적 복사가 필요한 상황에서는 객체를 재사용하는 것보다는 객체를 생성해야 한다.  
- 방어적 복사에 실패하면 언제 터져 나올지 모르는 버그와 보안 구멍으로 이어지지만, 불필요한 객체 생성은 그저 코드 형태와 성능에만 영향을 준다.
