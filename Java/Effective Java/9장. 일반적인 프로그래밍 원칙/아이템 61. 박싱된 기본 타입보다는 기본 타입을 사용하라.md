# 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라

---

자바의 `int`, `double`, `boolean` 같은 기본 타입에는 각각 대응하는 참조 타입이 하나씩 있으며, 이를 **박싱된 기본 타입**이라고 한다.
- `Integer`, `Double`, `Boolean`

오토박싱과 오토언박싱 덕분에 두 타입을 구분하지 않고 사용할 수 있지만, 그렇다고 차이가 사라지는 것은 아니다.

## 기본 타입 vs 박싱된 기본 타입

---

- 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 **식별성이란 속성을 갖는다.**
  - 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.
- 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, **즉 null을 가질 수 있다.**
- 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

이러한 차이 때문에 주의하지 않고 사용하면 문제가 발생할 수 있다.

## 주의하지 않고 사용할 경우의 문제점

---

### 동일성 문제

```java
Comparator<Integer> naturalOrder =
    (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);

System.out.println(natural.Order.compare(new Integer(42), new Integer(42)));    //1
```

두 인스턴스의 값이 42로 같으므로 0을 출력해야 하지만, 실제로는 1을 출력한다.  
- 동일성(`==`) 비교는 객체 참조의 식별성을 검사해서 `false`가 나오기 때문이다.
- `equals` 연산자를 사용하자!

### null 문제

```java
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42)
            System.out.println("믿을 수 없군!");
    }
}
```

박싱된 기본 타입은 다른 참조 타입 필드와 마찬가지로 `null`이 올 수 있다.
- **기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.**
- 그리고 `null` 참조를 언박싱하면 `NullPointerException`이 발생한다.

### 성능 문제

```java
public static void main(String[]args){
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}
```

박싱과 언박싱이 반복해서 일어나 체감될 정도로 성능이 느려진다.

## 박싱된 기본 타입이 적절히 쓰이는 경우

---

- 컬렉션의 원소, 키, 값으로 쓴다.
  - 컬렉션은 기본 타입을 담을 수 없으므로 어쩔 수 없이 박싱된 기본 타입을 써야만 한다.
- 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.

## 핵심 정리

---

- 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하자.
  - 기본 타입은 간단하고 빠르다.
- 박싱된 기본 타입을 써야 한다면 주의를 기울이자.
  - **오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.**
