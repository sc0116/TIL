# 1. 예외와 예외 클래스

- 예외란 **사용자의 잘못된 조작** 또는 **개발자의 잘못된 코딩**으로 인해 발생하는 프로그램 오류를 말한다.
- 예외가 발생되면 프로그램은 곧바로 종료된다는 점에서는 에러와 동일하다.
- 그러나 예외는 **예외 처리(Exception Handling)** 를 통해 프로그램을 종료하지 않고 **정상 실행 상태가 유지**되도록 할 수 있다.

<br>

- 예외는 **일반 예외(Exception)** 와 **실행 예외(Runtime Exception)** 가 있다.
- 일반 예외는 **컴파일러 체크 예외**라고도 하는데, 자바 소스를 컴파일하는 과정에서 예외 처리 코드가 필요한지 검사하기 때문이다.
- 만약 예외 처리 코드가 없다면 컴파일 오류가 발생한다.
- 실행 예외는 컴파일하는 과정에서 예외 처리 코드를 검사하지 않는 예외를 말한다.
- 컴파일 시 예외 처리를 확인하는 차이일 뿐, 두 가지 예외는 모두 예외 처리가 필요하며, 자바에서는 예외를 **클래스로 관리**한다.
- JVM은 프로그램을 실행하는 도중에 예외가 발생하면 해당 예외 클래스로 객체를 생성하고, 예외 처리 코드에서 예외 객체를 이용할 수 있도록 해준다.
- 모든 예외 클래스들은 다음과 같이 **java.lang.Exception 클래스를 상속**받는다.

![예외 종류](https://user-images.githubusercontent.com/47477359/144597109-d4dbd0fe-528c-4c53-ba6e-5d1bf3db0b3c.png)

- 일반 예외는 **Exception을 상속**받지만 RuntimeException을 상속받지 않는 클래스들이고, 실행 예외는 **RuntimeException을 상속**받은 클래스들이다.
- RuntimeException 역시 Exception을 상속받지만, JVM은 RuntimeException을 상속했는지 여부를 보고 실행 예외를 판단한다.

# 2. 실행 예외

- 실행 예외는 자바 컴파일러가 체크를 하지 않기 때문에 오로지 **개발자의 경험**에 의해서 예외 처리 코드를 삽입해야 한다.
- 만약 개발자가 실행 예외에 대해 예외 처리 코드를 넣지 않았을 경우, 해당 예외가 발생하면 프로그램은 곧바로 종료된다.
- 자바 프로그램에서 자주 발생되는 실행 예외이므로 언제 발생되고, 어떤 오류 메시지가 출력되는지 잘 알아둘 필요가 있다.

## NullPointerException

- 이것은 객체 참조가 없는 상태, 즉 **null 값을 갖는 참조 변수**로 객체 접근 연산자인 도트(.)를 사용했을 때 발생한다.
- 객체가 없는 상태에서 객체를 사용하려 했으니 예외가 발생하는 것이다.

```java
public class NullPointerExceptionExample {
	public static void main(String[] args) {
        String data = null;
		System.out.println(data.toString());
	}
}
```

- 프로그램에서 예외가 발생하면 예외 메시지가 Console 뷰에 출력되면서 프로그램이 종료된다.
- Console 뷰에 출력되는 내용에는 어떤 예외가 어던 소스의 몇 번째 코드에서 발생했는지에 대한 정보가 들어있다.

## ArrayIndexOutOfBoundsException

- 배열에서 **인덱스 범위를 초과**하여 사용할 경우 발생한다.

```java
public class ArrayIndexOutOfBoundsExceptionExample {
	public static void main(String[] args) {
        String data1 = args[0];
        String data2 = args[1];

		System.out.println("args[0]: " + data1);
		System.out.println("args[1]: " + data2);
	}
}
```

## NumberFormatException

- 프로그램을 개발하다 보면 문자열로 되어 있는 데이터를 숫자로 변경하는 경우가 자주 발생한다.

반환 타입|메소드명(매개 변수)|설명
:---|:---|:---
int|Integer.parseInt(String s)|주어진 문자열을 정수로 변환해서 리턴
double|Double.parseDouble(String s)|주어진 문자열을 실수로 변환해서 리턴

- 이 메소드들은 매개값인 문자열이 숫자로 변환될 수 있다면 숫자를 리턴하지만, **숫자로 변환될 수 없는 문자가 포함**되어 있다면 발생한다.

```java
public class NumberFormatExceptionExample {
	public static void main(String[] args) {
        String data1 = "100";
        String data2 = "a100";
        
        int value1 = Integer.parseInt(data1);
        int value2 = Integer.parseInt(data2);   //NumberFormatException 발생
        
        int result = value1 + value2;
		System.out.println(data1 + " + " + data2 + " = " + result);
	}
}
```

## ClassCastException

- 타입 변환(Casting)은 상위 클래스와 하위 클래스 간에 발생하고 구현 클래스와 인터페이스 간에도 발생한다.
- 이러한 관계가 아니라면 클래스는 다른 클래스로 타입 변환할 수 없다.
- **억지로 타입 변환**을 시도할 경우 발생한다.
- ClassCastException을 발생시키지 않으려면 타입 변환 전에 타입 변환이 가능한지 **instanceof 연산자로 확인**하는 것이 좋다.
- instanceof 연산의 결과가 true이면 좌항 객체를 우항 타입으로 변환이 가능하다는 뜻이다.

```java
Animal animal = new Dog();
if (animal instanceof Dog) {
	Dog dog = (Dog) animal;
} else if (animal instanceof Cat) {
	Cat cat = (Cat) animal;
}
```
