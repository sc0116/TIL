# 1. 람다식이란?
- 자바는 함수적 프로그래밍을 위해 자바8부터 람다식(Lambda Expressions)을 지원합니다.
- 람다식은 **익명 함수(anonymous function)를 생성**하기 위한 식입니다.
- 람다식의 형태는 **매개 변수를 가진 코드 블록**이지만, 런타임 시에는 익명 구현 객체를 생성합니다.

# 2. 람다식 기본 문법
```java
(타입 매개변수, ...) -> { 실행문; ... }
```
- (타입 매개변수, ...)는 오른쪽 중괄호 {} 블록을 실행하기 위해 **필요한 값을 제공**하는 역할을 합니다.
- -> 기호는 매개 변수를 이용해서 중괄호 {}를 실행한다는 뜻으로 해석하면 됩니다.
```java
(int a) -> { System.out.println(a); }
```
- 매개 변수 타입은 **런타임 시에 대입되는 값에 따라 자동으로 인식**될 수 있기 때문에 람다식에서는 매개 변수의 타입을 일반적으로 언급하지 않습니다.
```java
(a) -> { System.out.println(a); }
```
- 하나의 매개 변수만 있다면 괄호 ()를 생략할 수 있고, 하나의 실행문만 있다면 중괄호 {}도 생략할 수 있습니다.
```java
a -> System.out.println(a);
```
- 만약 매개 변수가 없다면 람다식에서 매개 변수 자리가 없어지므로 빈 괄호 ()를 반드시 사용해야 합니다.
```java
() -> { 실행문; ... }
```
- 중괄호 {}를 실행하고 결과값을 리턴해야 한다면 return문으로 결과값을 지정할 수 있습니다.
```java
(x, y) -> { return x + y; }
```
- 중괄호 {}에 return문만 있을 경우, 람다식에서는 return문을 사용하지 않고 작성하는 것이 정석입니다.
```java
(x, y) -> x + y
```

# 3. 타겟 타입과 함수적 인터페이스
- 람다식은 단순히 메소드를 선언하는 것이 아니라 이 메소드를 가지고 있는 객체를 생성해 냅니다.
```java
인터페이스 변수 = 람다식;
```
- 람다식은 인터페이스의 익명 구현 객체를 생성합니다.
- 람다식이 대입될 인터페이스를 람다식의 타겟 타입(target type)이라고 합니다.

## 함수적 인터페이스(@FunctionalInterface)
- 람다식이 하나의 메소드를 정의하기 때문에 **하나의 추상 메소드가 선언된 인터페이스**만이 람다식의 타겟 타입이 될 수 있는데, 이러한 인터페이스를 함수적 인터페이스라고 합니다.
- @FunctionalInterface 어노테이션을 붙이면 두 개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체킹해줍니다. (선택사항)

## 매개 변수와 리턴값이 없는 람다식
```java
@FunctionalInterface
public interface MyFunctionalInterface {
    public void method();
}

MyFunctionalInterface fi = () -> { System.out.println("Hi");
fi.method();
```
- method()가 매개 변수를 가지지 않기 때문에 람다식에 매개 변수가 없습니다.
- 람다식이 대입된 인터페이스와 참조 변수는 method()를 호출할 수 있습니다.
- method() 호출은 람다식의 중괄호 {}를 실행시킵니다.

## 매개 변수가 있는 람다식
```java
@FunctionalInterface
public interface MyFunctionalInterface {
    public void method(int x);
}

MyFunctionalInterface fi = (x) -> { ... } 또는 x -> { ... }
fi.method(5);
```
- 매개값을 주면 람다식의 x변수에 대입되고 x는 중괄호 {}에서 사용됩니다.

## 리턴값이 있는 람다식
```java
@FunctionalInterface
public interface MyFunctionalInterface {
    public int method(int x, int y);
}

MyFunctionalInterface fi = (x, y) -> { ...; return 값; }
int result = fi.method(2, 5);
```
- method()가 리턴 타입이 있기 때문에 중괄호 {}에는 return문이 있어야 합니다.

# 4. 클래스 멤버와 로컬 변수 사용
- 람다식의 실행 블록에는 클래스의 멤버(필드와 메소드) 및 로컬 변수를 사용할 수 있습니다.

## 클래스의 멤버 사용
- 람다식 실행 블록에는 클래스의 멤버인 필드와 메소드를 제약 사항 없이 사용할 수 있지만, this 키워드를 사용할 때에는 주의가 필요합니다.
- 일반적으로 익명 객체 내부에서 this는 익명 객체의 참조이지만, 람다식에서 this는 람다식을 실행한 객체의 참조입니다.
```java
public interface MyFunctionalInterface {
    public void method();
}

public class UsingThis {
    public int outterField = 10;
    
    class Inner {
        int innerField = 20;
        
        void method() {
            MyFunctionalInterface fi = () -> {
                System.out.println("outterField: " + UsingThis.this.outterField);
                System.out.println("innerField: " + this.innerField);
            };
            fi.method();
        }
    }
}
```
- 바깥 객체의 참조를 얻기 위해서는 클래스면.this를 사용합니다.
- 람다식 내부에서 this는 Inner 객체를 참조합니다. 

## 로컬 변수 사용
- 람다식에서 메소드의 매개 변수 또는 로컬 변수를 사용하면 이 두 변수는 **final 특성**을 가져야 합니다.
- 따라서 매개 변수 또는 로컬 변수를 **람다식에서 읽는 것은 허용**되지만, 람다식 내부 또는 외부에서 변경할 수 없습니다.
```java
public interface MyFunctionalInterface {
    public void method();
}

public class UsingLocalVariable {
    void method(int arg) {  //arg는 final 특성을 가짐
        int localVar = 40;  //localVar는 final 특성을 가짐
        
        //arg = 31;
        //localVar = 41;
        
        MyFunctionalInterface fi = () -> {
            System.out.println("arg: " + arg);
            System.out.println("localVar: " + localVar);
        };
        fi.method();
    }
}
```
- arg와 localVar 변수는 final 특성 때문에 수정이 불가합니다.

# 5. 표준 API의 함수적 인터페이스

# 6. 메소드 참조
- 메소드 참조(Method References)는 메소드를 참조해서 매개 변수의 정보 및 리턴 타입을 알아내어, 람다식에서 **불필요한 매개 변수를 제거하는 것**이 목적입니다.

## 정적 메소드와 인스턴스 메소드 참조
- 정적(static) 메소드를 참조할 경우에는 클래스 이름 뒤에 :: 기호를 붙이고 정적 메소드 이름을 기술합니다.
```java
클래스 :: 메소드
```
- 인스턴스 메소드일 경우에는 먼저 객체를 생성한 다음 참조 변수 뒤에 :: 기호를 붙이고 인스턴스 메소드 이름을 기술합니다.
```java
참조변수 :: 메소드
```
```java
public class Calculator {
    public static int staticMethod(int x, int y) {
        return x + y;
    }
    
    public int instanceMethod(int x, int y) {
        return x + y;
    }
}

public class MethodReferencesExample {
    public static void main(String[] args) {
        IntBinaryOperator operator;
        
        //정적 메소드 참조
        operator = (x, y) -> Calculator.staticMethod(x, y);
        System.out.println("결과1: " + operator.applyAsInt(1, 2));
        
        operator = Calculator :: staticMethod;
        System.out.println("결과2: " + operator.applyAsInt(3, 4));
        
        //인스턴스 메소드 참조
        Calculator obj = new Calculator();
        operator = (x, y) -> obj.instanceMethod(x, y);
        System.out.println("결과3: " + operator.applyAsInt(5, 6));
        
        operator = obj :: instanceMethod;
        System.out.println("결과4: " + operator.applyAsInt(7, 8));
        
    }
}
```

## 매개 변수의 메소드 참조
- 람다식에서 제공되는 a 매개 변수의 메소드를 호출해서 b 매개 변수를 매개값으로 사용하는 경우입니다.
```java
(a, b) -> { a.instanceMethod(b); }
```
- a의 클래스 이름 뒤에 :: 기호를 붙이고 메소드 이름을 기술합니다.
```java
클래스 :: instanceMethod
```

## 생성자 참조
- 단순히 객체를 생성하고 리턴하도록 구성된 람다식은 생성자 참조로 대치할 수 있습니다.
```java
(a, b) -> { return new 클래스(a, b); }
```
- 클래스 이름 뒤에 :: 기호를 붙이고 new 연산자를 기술합니다.
```java
클래스 :: new
```
```java
public class ConstructorReferencesExample {
    public static void main(String[] args) {
        Function<String, Member> f1 = Member :: new;
        Member m1 = f1.apply("angel");
        
        BiFunction<String, Member> f2 = Member :: new;
        Member m2 = f2.apply("신짱구", "angel");
    }
}

public class Member {
    private String name;
    private String id;
    
    public Member() {
        System.out.println("Member) 실행");
    }
    
    public Member(String id) {
        System.out.println("Member(String id) 실행");
        this.id = id;
    }
    
    public Member(String name, String id) {
        System.out.println("Member(String name, String id");
        this.name = name;
        this.id = id;
    }
    
    public String getId() { return id; }
}
```