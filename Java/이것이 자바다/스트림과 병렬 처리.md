# 1. 스트림 소개
- 스트림(Stream)은 자바 8부터 추가된 컬렉션(배열 포함)의 **저장 요소를 하나씩 참조해서 람다식(함수적-스타일)으로 처리**할 수 있도록 해주는 반복자이다.

## 반복자 스트림
- 자바 7 이전까지는 List<String> 컬렉션에서 요소를 순차적으로 처리하기 위해 Iterator 반복자를 사용해왔다.
```java
List<String> list = Arrays.asList("홍길동", "신용권", "김자바");
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String name = iterator.next();
    System.out.println(name);
}
```
- 이 코드를 Stream을 사용해서 변경하면 다음과 같다.
```java
List<String> list = Arrays.asList("홍길동", "신용권", "김자바");
Stream<String> stream = list.stream();
stream.forEach( name -> System.out.println(name) );
```
- forEach() 메소드는 다음과 같이 Consumer 함수적 인터페이스 타입의 매개값을 가지므로 컬렉션의 요소를 소비할 코드를 람다식으로 기술할 수 있다.
```java
void forEach(Consumer<T> action)
```
- Iterator를 사용한 코드와 Stream을 사용한 코드를 비교해보면 Stream을 사용하는 것이 훨씬 단순해 보인다.

## 스트림의 특징
- Stream은 Iterator와 비슷한 역할을 하는 반복자이지만, 람다식으로 요소 처리 코드를 제공하는 점과 내부 반복자를 사용하므로 병렬 처리가 쉽다는 점 그리고 중간 처리와 최종 처리 작업을 수행하는 점에서 많은 차이를 가지고 있다.

### 람다식으로 요소 처리 코드를 제공한다.
- Stream이 제공하는 대부분의 요소 처리 메소드는 함수적 인터페이스 매개 타입을 가지기 때문에 람다식 또는 메소드 참조를 이용해서 요소 처리 내용을 매개값으로 전달할 수 있다.
```java
public class LambdaExpressionsExample {
    public static void main(String[] args) {
        List<Student> list = Arrays.asList(
                new Student("홍길동", 90),
                new Student("신용권", 92)
        );
        
        Stream<Student> stream = list.stream();
        stream.forEach( s -> {
            String name = s.getName();
            int score = s.getScore();
            System.out.println(name + " : " + score);
        });
    }
}

public class Student {
    private String name;
    private int score;
    
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    
    public String getName() {
        return name;
    }
    
    public int getScore() {
        return score;
    }
}
```

### 내부 반복자를 사용하므로 병렬 처리가 쉽다.
- 외부 반복자(external iterator)란 개발자가 코드로 직접 컬렉션의 요소를 반복해서 가져오는 코드 패턴을 말한다.
- index를 이용하는 for문, Iterator를 이용하는 while문은 모두 외부 반복자를 이용하는 것이다.
- 반면에 내부 반복자(internal iterator)는 **컬렉션 내부에서 요소들을 반복**시키고, 개발자는 **요소당 처리해야 할 코드만 제공**하는 코드 패턴을 말한다.
- 내부 반복자를 사용해서 얻는 이점은 컬렉션 내부에서 어떻게 요소를 반복시킬 것인가는 컬렉션에 맡겨두고, 개발자는 **요소 처리 코드에만 집중**할 수 있다는 것이다.
- 내부 반복자는 요소들의 반복 순서를 변경하거나, 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배시켜 **병렬 작업**을 할 수 있게 도와주기 때문에 하나씩 처리하는 순차적 외부 반복자보다는 **효율적으로 요소를 반복**시킬 수 있다.
```java
public class ParallelExample {
    public static void main(String[] args) {
        List<String> list = Arrays.asList(
                "홍길동", "신용권", "김자바",
                "람다식", "박병렬"
        );
        
        //순차 처리
        Stream<String> stream = list.stream();
        stream.forEach( ParallelExample :: print ); //메소드 참조(s -> ParallelExample.print(s)와 동일)
        System.out.println();
        
        //병렬 처리
        Stream<String> parallelStream = list.parallelStream();
        parallelStream.forEach( ParallelExample :: print );
    }
    
    public static void print(String str) {
        System.out.println(str + " : " + Thread.currentThread().getName());
    }
}

실행 결과
홍길동: main
신용권: main
김자바: main
람다식: main
박병렬: main

김자바: main
박병렬: ForkJoinPool.commonPool-worker-2
신용권: ForkJoinPool.commonPool-worker-1
람다식: main
홍길동: ForkJoinPool.commonPool-worker-2
```

### 스트림은 중간 처리와 최종 처리를 할 수 있다.
- 스트림은 컬렉션의 요소에 대해 중간 처리와 최종 처리를 수행할 수 있는데, 중간 처리에서는 **매핑, 필터링, 정렬**을 수행하고 최종 처리에서는 **반복, 카운팅, 평균, 총합 등의 집계 처리**를 수행한다.
- 다음 예제는 List에 저장되어 있는 Student 객체를 중간 처리에서 scroe 필드값으로 매핑하고, 최종 처리에서 score의 평균값을 산출한다.
```java
public class MapAndReduceExample {
    public static void main(String[] args) {
        List<Student> studentList = Arrays.asList(
                new Student("홍길동", 10),
                new Student("신용권", 20),
                new Student("유미선", 30)
        );
        
        double avg = studentList.stream()
                //중간 처리(학생 객체를 점수로 매핑)
                .mapToInt(Student :: getScore)
                //최종 처리(평균 점수)
                .average()
                .getAsDouble();

        System.out.println("평균 점수: " + avg);    //20.0
    }
}
```

# 2. 스트림의 종류
- 자바 8부터 새로 추가된 java.util.stream 패키지에는 스트림 API들이 포진하고 있다.
- 패키지 내용을 보면 BaseStream 인터페이스를 부모로 해서 자식 인터페이스들이 상속 관계를 이루고 있다.

![스트림의 종류](https://user-images.githubusercontent.com/47477359/143688972-b4429665-09fa-4ded-a08f-f40b9f4a6fdb.png)
- BaseStream 인터페이스에는 모든 스트림에서 사용할 수 있는 공통 메소드들이 정의되어 있을 뿐 코드에서 직접적으로 사용되지는 않는다.
- Stream은 **객체 요소를 처리**하는 스트림이고, IntStream, LongStream, DoubleStream은 각각 기본 타입인 **int, long, double 요소를 처리**하는 스트림이다.
- 스트림 인터페이스의 구현 객체는 주로 컬렉션과 배열에서 얻지만, 다음과 같은 소스로부터 스트림 구현 객체를 얻을 수도 있다.

리턴 타입|메소드(매개 변수)|소스
:---|:---|:---
Stream\<T>|java.util.Collection.stream()<br>java.util.Collection.parallelStream()|컬렉션
Stream\<T><br>IntStream<br>LongStream<br>DoubleStream|Arrays.stream(T[]),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream.of(T[])<br>Arrays.stream(int[]),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IntStream.of(int[])<br>Arrays.stream(long[]),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LongStream.of(long[])<br>Arrays.stream(double[]),&nbsp;DoubleStream.of(double[])|배열
IntStream|IntStream.range(int, int)<br>IntStream.rangeClosed(int, int)|int 범위
LongStream|LongStream.range(long, long)<br>LongStream.rangeClosed(long, long)|long 범위
Stream\<Path>|Files.find(Path, int, BiPredicate, FileVisitOption)<br>Files.list(Path)|디렉토리
Stream\<String>|Files.lines(Path, Charset)<br>BufferedReader.lines()|파일
DoubleStream<br>IntStream<br>LongStream|Random.doubles()<br>Random.ints()<br>Random.longs()|랜덤 수

## 컬렉션으로부터 스트림 얻기
- 다음 예제는 List<Student> 컬렉션에서 Stream<Student>를 얻어내고 콘솔에 출력한다.
```java
public class  FromCollectionExample {
    public static void main(String[] args) {
        List<Student> studentList = Arrays.asList(
                new Student("홍길동", 10),
                new Student("신용권", 20),
                new Student("유미선", 30)
        );
        
        Stream<Student> stream = studentList.stream();
        stream.forEach(s -> System.out.println(s.getName));
    }
}
```

## 배열로부터 스트림 얻기
- 다음 예제는 String[]과 int[] 배열로부터 스트림을 얻어내고 콘솔에 출력한다.
```java
public class FromArrayExample {
    public static void main(String[] args) {
        String[] strings = { "홍길동", "신용권", "김자바" };
        Stream<String> stringStream = Arrays.stream(strings);
        stringStream.forEach(a -> System.out.println(a + ","));
        System.out.println();
        
        int[] ints = { 1, 2, 3, 4, 5 };
        IntStream intStream = Arrays.stream(ints);
        intStream.forEach(a -> System.out.println(a + ","));
    }
}
```

## 숫자 범위로부터 스트림 얻기
- 다음 예제는 1부터 100까지의 합을 구하기 위해 IntStream의 rangeClosed() 메소드를 이용하였다.
- rangeClosed()는 첫 번째 매개값에서부터 두 번째 매개값까지 순차적으로 제공하는 IntStream을 리턴한다.
- range() 메소드도 동일한 IntStream을 리턴하는데, 두 번째 매개값은 포함하지 않는다.
```java
public class FromIntRangeExample {
    public static int sum;

    public static void main(String[] args) {
        IntStream stream = IntStream.rangeClosed(1, 100);
        stream.forEach(a -> sum += a);
        System.out.println("총합: " + sum);
    }
}
```

## 파일로부터 스트림 얻기
- 다음 예제는 Files의 정적 메소드인 lines()와 BufferedReader의 lines() 메소드를 이용하여 문자 파일의 내용을 스트림을 통해 행 단위로 읽고 콘솔에 출력한다.
```java
public class FromFileContentExample {
    public static void main(String[] args) throws IOException {
        Path path = Paths.get("파/일/경/로.txt");
        Stream<String> stream;
        
        //Files.lines() 메소드 이용
        stream = Files.lines(path, Charset.defaultCharset());
        stream.forEach(System.out :: println);
        System.out.println();
        
        //BufferedReader의 lines() 메소드 이용
        File file = path.toFile();
        FileReader fileReader = new FileReader(file);
        BufferedReader br = new BufferedReader(fileReader);
        stream = br.lines();
        stream.forEach(System.out :: println);
    }
}
```

## 디렉토리로부터 스트림 얻기
- 다음 예제는 Files의 정적 메소드인 list()를 이용해서 디렉토리의 내용(서브 디렉토리 또는 파일 목록)을 스트림을 통해 읽고 콘솔에 출력한다.
```java
public class FromDirectoryExample {
    public static void main(String[] args) {
        Path path = Paths.get("C:/파일경로/source");
        Stream<Path> stream = Files.list(path);
        stream.forEach(p -> System.out.println(p.getFileName()));
    }
}
```

# 3. 스트림 파이프라인
- **대량의 데이터를 가공해서 축소하는 것**을 일반적으로 리덕션(Reduction)이라고 하는데, **데이터의 합계, 평균값, 카운팅, 최대값, 최소값** 등이 대표적인 리덕션의 결과물이라고 볼 수 있다.
- 그러나 컬렉션의 요소를 리덕션의 결과물로 바로 집계할 수 없을 경우에는 집계하기 좋도록 필터링, 매핑, 정렬, 그룹핑 등의 중간 처리가 필요하다.

## 중간 처리와 최종 처리
- 스트림은 데이터의 필터링, 매핑, 정렬, 그룹핑 등의 중간 처리와 합계, 평균, 카운팅, 최대값, 최소값 등의 최종 처리를 파이프라인(pipelines)으로 해결한다.
- 파이프라인은 **여러 개의 스트림이 연결되어 있는 구조**를 말한다.
- 파이프라인에서 최종 처리를 제외하고는 모두 중간 처리 스트림이다.

![파이프라인](https://user-images.githubusercontent.com/47477359/143765285-3fa452fc-fa81-4153-8606-f455f8af3ffc.png)
- 중간 스트림이 생성될 때 요소들이 바로 중간 처리되는 것이 아니라 최종 처리가 시작되기 전까지 지연(lazy)된다.
- 최종 처리가 시작되면 비로소 컬렉션의 요소가 하나씩 중간 스트림에서 처리되고 최종 처리까지 오게 된다.
- Stream 인터페이스에는 필터링, 매핑, 정렬 등의 많은 중간 처리 메소드가 있는데, 이 메소드들은 중간 처리된 스트림을 리턴한다.
- 그리고 이 스트림에서 다시 중간 처리 메소드를 호출해서 파이프라인을 형성하게 된다.

![파이프라인 예시](https://user-images.githubusercontent.com/47477359/143765400-113195dc-720c-4b5f-a138-63db62f0682f.png)
- 예를 들어 회원 컬렉션에서 남자만 필터링하는 중간 스트림을 연결하고, 다시 남자의 나이로 매핑하는 스트림을 연결한 후, 최종 남자 평균 나이를 집계했을 때 형성되는 파이프라인이다.

```java
public class StreamPipelinesExample {
    public static void main(String[] args) {
        List<Member> list = Arrays.asList(
                new Member("홍길동", Member.MALE, 30),
                new Member("김나리", Member.FEMALE, 20),
                new Member("신용권", Member.MALE, 45),
                new Member("박수미", Member.FEMALE, 27)
        );
        
        double ageAvg = list.stream()                       //오리지날 스트림
                .filter(m -> m.getGender() == Member.MALE)  //중간 처리 스트림
                .mapToInt(Member :: getAge)                 //중간 처리 스트림
                .average()                                  //최종 처리
                .getAsDouble();

        System.out.println("남자 평균 나이: " +ageAvg);
    }
}
```

## 중간 처리 메소드와 최종 처리 메소드

<table>
<tr><th colspan="2">종류</th><th>리턴 타입</th><th>메소드(매개 변수)</th><th>소속된 인터페이스</th></tr>
<tr><td rowspan="16">중간 처리</td><td rowspan="2">필터링</td><td rowspan="16">Stream<br>IntStream<br>LongStream<br>DoubleStream</td><td>distinct()</td><td>공통</td></tr>
<tr><td>filter(...)</td><td>공통</td></tr>
<tr><td rowspan="12">매핑</td><td>flatMap(...)</td><td>공통</td></tr>
<tr><td>flatMapToDouble(...)</td><td>Stream</td></tr>
<tr><td>flatMapToInt(...)</td><td>Stream</td></tr>
<tr><td>flatMapToLong(...)</td><td>Stream</td></tr>
<tr><td>map(...)</td><td>공통</td></tr>
<tr><td>mapToDouble(...)</td><td>Stream, IntStream, LongStream</td></tr>
<tr><td>mapToInt(...)</td><td>Stream, LongStream, DoubleStream</td></tr>
<tr><td>mapToLong(...)</td><td>Stream, IntStream, DoubleStream</td></tr>
<tr><td>mapToObj(...)</td><td>IntStream, LongStream, DoubleStream</td></tr>
<tr><td>asDoubleStream()</td><td>IntStream, LongStream</td></tr>
<tr><td>asLongStream()</td><td>IntStream</td></tr>
<tr><td>boxed()</td><td>IntStream, LongStream, DoubleStream</td></tr>
<tr><td>정렬</td><td>sorted(...)</td><td>공통</td></tr>
<tr><td>루핑</td><td>peek(...)</td><td>공통</td></tr>

<tr><td rowspan="12">최종 처리</td><td rowspan="3">매칭</td><td>boolean</td><td>allMatch(...)</td><td>공통</td></tr>
<tr><td>boolean</td><td>anyMatch(...)</td><td>공통</td></tr>
<tr><td>boolean</td><td>noneMatch(...)</td><td>공통</td></tr>
<tr><td rowspan="7">집계</td><td>long</td><td>count()</td><td>공통</td></tr>
<tr><td>OptionalXXX</td><td>findFirst()</td><td>공통</td></tr>
<tr><td>OptionalXXX</td><td>max(...)</td><td>공통</td></tr>
<tr><td>OptionalXXX</td><td>min(...)</td><td>공통</td></tr>
<tr><td>OptionalDouble</td><td>average()</td><td>IntStream, LongStream, DoubleStream</td></tr>
<tr><td>OptionalXXX</td><td>reduce(...)</td><td>공통</td></tr>
<tr><td>int, long, double</td><td>sum()</td><td>IntStream, LongStream, DoubleStream</td></tr>
<tr><td>루핑</td><td>void</td><td>forEach(...)</td><td>공통</td></tr>
<tr><td>수집</td><td>R</td><td>collect(...)</td><td>공통</td></tr>
</table>

- 중간 처리 메소드와 최종 처리 메소드를 쉽게 구분하는 방법은 리턴 타입을 보면 된다.
- 리턴 타입이 **스트림**이라면 중간 처리 메소드이고, **기본 타입이거나 OptionalXXX**라면 최종 처리 메소드이다.
- 소속된 인터페이스에서 공통의 의미는 Stream, IntStream, LongStream, DoubleStream에서 모두 제공된다는 뜻이다.
