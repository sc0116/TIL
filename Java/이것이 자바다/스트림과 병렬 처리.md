# 1. 스트림 소개
- 스트림(Stream)은 자바 8부터 추가된 컬렉션(배열 포함)의 **저장 요소를 하나씩 참조해서 람다식(함수적-스타일)으로 처리**할 수 있도록 해주는 반복자이다.

## 반복자 스트림
- 자바 7 이전까지는 List<String> 컬렉션에서 요소를 순차적으로 처리하기 위해 Iterator 반복자를 사용해왔다.
```java
List<String> list = Arrays.asList("홍길동", "신용권", "김자바");
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String name = iterator.next();
    System.out.println(name);
}
```
- 이 코드를 Stream을 사용해서 변경하면 다음과 같다.
```java
List<String> list = Arrays.asList("홍길동", "신용권", "김자바");
Stream<String> stream = list.stream();
stream.forEach( name -> System.out.println(name) );
```
- forEach() 메소드는 다음과 같이 Consumer 함수적 인터페이스 타입의 매개값을 가지므로 컬렉션의 요소를 소비할 코드를 람다식으로 기술할 수 있다.
```java
void forEach(Consumer<T> action)
```
- Iterator를 사용한 코드와 Stream을 사용한 코드를 비교해보면 Stream을 사용하는 것이 훨씬 단순해 보인다.

## 스트림의 특징
- Stream은 Iterator와 비슷한 역할을 하는 반복자이지만, 람다식으로 요소 처리 코드를 제공하는 점과 내부 반복자를 사용하므로 병렬 처리가 쉽다는 점 그리고 중간 처리와 최종 처리 작업을 수행하는 점에서 많은 차이를 가지고 있다.

### 람다식으로 요소 처리 코드를 제공한다.
- Stream이 제공하는 대부분의 요소 처리 메소드는 함수적 인터페이스 매개 타입을 가지기 때문에 람다식 또는 메소드 참조를 이용해서 요소 처리 내용을 매개값으로 전달할 수 있다.
```java
public class LambdaExpressionsExample {
    public static void main(String[] args) {
        List<Student> list = Arrays.asList(
                new Student("홍길동", 90),
                new Student("신용권", 92)
        );
        
        Stream<Student> stream = list.stream();
        stream.forEach( s -> {
            String name = s.getName();
            int score = s.getScore();
            System.out.println(name + " : " + score);
        });
    }
}

public class Student {
    private String name;
    private int score;
    
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    
    public String getName() {
        return name;
    }
    
    public int getScore() {
        return score;
    }
}
```

### 내부 반복자를 사용하므로 병렬 처리가 쉽다.
- 외부 반복자(external iterator)란 개발자가 코드로 직접 컬렉션의 요소를 반복해서 가져오는 코드 패턴을 말한다.
- index를 이용하는 for문, Iterator를 이용하는 while문은 모두 외부 반복자를 이용하는 것이다.
- 반면에 내부 반복자(internal iterator)는 **컬렉션 내부에서 요소들을 반복**시키고, 개발자는 **요소당 처리해야 할 코드만 제공**하는 코드 패턴을 말한다.
- 내부 반복자를 사용해서 얻는 이점은 컬렉션 내부에서 어떻게 요소를 반복시킬 것인가는 컬렉션에 맡겨두고, 개발자는 **요소 처리 코드에만 집중**할 수 있다는 것이다.
- 내부 반복자는 요소들의 반복 순서를 변경하거나, 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배시켜 **병렬 작업**을 할 수 있게 도와주기 때문에 하나씩 처리하는 순차적 외부 반복자보다는 **효율적으로 요소를 반복**시킬 수 있다.
```java
public class ParallelExample {
    public static void main(String[] args) {
        List<String> list = Arrays.asList(
                "홍길동", "신용권", "김자바",
                "람다식", "박병렬"
        );
        
        //순차 처리
        Stream<String> stream = list.stream();
        stream.forEach( ParallelExample :: print ); //메소드 참조(s -> ParallelExample.print(s)와 동일)
        System.out.println();
        
        //병렬 처리
        Stream<String> parallelStream = list.parallelStream();
        parallelStream.forEach( ParallelExample :: print );
    }
    
    public static void print(String str) {
        System.out.println(str + " : " + Thread.currentThread().getName());
    }
}

실행 결과
홍길동: main
신용권: main
김자바: main
람다식: main
박병렬: main

김자바: main
박병렬: ForkJoinPool.commonPool-worker-2
신용권: ForkJoinPool.commonPool-worker-1
람다식: main
홍길동: ForkJoinPool.commonPool-worker-2
```

### 스트림은 중간 처리와 최종 처리를 할 수 있다.
- 스트림은 컬렉션의 요소에 대해 중간 처리와 최종 처리를 수행할 수 있는데, 중간 처리에서는 **매핑, 필터링, 정렬**을 수행하고 최종 처리에서는 **반복, 카운팅, 평균, 총합 등의 집계 처리**를 수행한다.
- 다음 예제는 List에 저장되어 있는 Student 객체를 중간 처리에서 scroe 필드값으로 매핑하고, 최종 처리에서 score의 평균값을 산출한다.
```java
public class MapAndReduceExample {
    public static void main(String[] args) {
        List<Student> studentList = Arrays.asList(
                new Student("홍길동", 10),
                new Student("신용권", 20),
                new Student("유미선", 30)
        );
        
        double avg = studentList.stream()
                //중간 처리(학생 객체를 점수로 매핑)
                .mapToInt(Student :: getScore)
                //최종 처리(평균 점수)
                .average()
                .getAsDouble();

        System.out.println("평균 점수: " + avg);    //20.0
    }
}
```
