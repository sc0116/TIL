# 1. 스트림 소개
- 스트림(Stream)은 자바 8부터 추가된 컬렉션(배열 포함)의 **저장 요소를 하나씩 참조해서 람다식(함수적-스타일)으로 처리**할 수 있도록 해주는 반복자이다.

## 반복자 스트림
- 자바 7 이전까지는 List<String> 컬렉션에서 요소를 순차적으로 처리하기 위해 Iterator 반복자를 사용해왔다.
```java
List<String> list = Arrays.asList("홍길동", "신용권", "김자바");
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String name = iterator.next();
    System.out.println(name);
}
```
- 이 코드를 Stream을 사용해서 변경하면 다음과 같다.
```java
List<String> list = Arrays.asList("홍길동", "신용권", "김자바");
Stream<String> stream = list.stream();
stream.forEach( name -> System.out.println(name) );
```
- forEach() 메소드는 다음과 같이 Consumer 함수적 인터페이스 타입의 매개값을 가지므로 컬렉션의 요소를 소비할 코드를 람다식으로 기술할 수 있다.
```java
void forEach(Consumer<T> action)
```
- Iterator를 사용한 코드와 Stream을 사용한 코드를 비교해보면 Stream을 사용하는 것이 훨씬 단순해 보인다.

## 스트림의 특징
- Stream은 Iterator와 비슷한 역할을 하는 반복자이지만, 람다식으로 요소 처리 코드를 제공하는 점과 내부 반복자를 사용하므로 병렬 처리가 쉽다는 점 그리고 중간 처리와 최종 처리 작업을 수행하는 점에서 많은 차이를 가지고 있다.

### 람다식으로 요소 처리 코드를 제공한다.
- Stream이 제공하는 대부분의 요소 처리 메소드는 함수적 인터페이스 매개 타입을 가지기 때문에 람다식 또는 메소드 참조를 이용해서 요소 처리 내용을 매개값으로 전달할 수 있다.
```java
public class LambdaExpressionsExample {
    public static void main(String[] args) {
        List<Student> list = Arrays.asList(
                new Student("홍길동", 90),
                new Student("신용권", 92)
        );
        
        Stream<Student> stream = list.stream();
        stream.forEach( s -> {
            String name = s.getName();
            int score = s.getScore();
            System.out.println(name + " : " + score);
        });
    }
}

public class Student {
    private String name;
    private int score;
    
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    
    public String getName() {
        return name;
    }
    
    public int getScore() {
        return score;
    }
}
```

### 내부 반복자를 사용하므로 병렬 처리가 쉽다.
- 외부 반복자(external iterator)란 개발자가 코드로 직접 컬렉션의 요소를 반복해서 가져오는 코드 패턴을 말한다.
- index를 이용하는 for문, Iterator를 이용하는 while문은 모두 외부 반복자를 이용하는 것이다.
- 반면에 내부 반복자(internal iterator)는 **컬렉션 내부에서 요소들을 반복**시키고, 개발자는 **요소당 처리해야 할 코드만 제공**하는 코드 패턴을 말한다.
- 내부 반복자를 사용해서 얻는 이점은 컬렉션 내부에서 어떻게 요소를 반복시킬 것인가는 컬렉션에 맡겨두고, 개발자는 **요소 처리 코드에만 집중**할 수 있다는 것이다.
- 내부 반복자는 요소들의 반복 순서를 변경하거나, 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배시켜 **병렬 작업**을 할 수 있게 도와주기 때문에 하나씩 처리하는 순차적 외부 반복자보다는 **효율적으로 요소를 반복**시킬 수 있다.
```java
public class ParallelExample {
    public static void main(String[] args) {
        List<String> list = Arrays.asList(
                "홍길동", "신용권", "김자바",
                "람다식", "박병렬"
        );
        
        //순차 처리
        Stream<String> stream = list.stream();
        stream.forEach( ParallelExample :: print ); //메소드 참조(s -> ParallelExample.print(s)와 동일)
        System.out.println();
        
        //병렬 처리
        Stream<String> parallelStream = list.parallelStream();
        parallelStream.forEach( ParallelExample :: print );
    }
    
    public static void print(String str) {
        System.out.println(str + " : " + Thread.currentThread().getName());
    }
}

실행 결과
홍길동: main
신용권: main
김자바: main
람다식: main
박병렬: main

김자바: main
박병렬: ForkJoinPool.commonPool-worker-2
신용권: ForkJoinPool.commonPool-worker-1
람다식: main
홍길동: ForkJoinPool.commonPool-worker-2
```

### 스트림은 중간 처리와 최종 처리를 할 수 있다.
- 스트림은 컬렉션의 요소에 대해 중간 처리와 최종 처리를 수행할 수 있는데, 중간 처리에서는 **매핑, 필터링, 정렬**을 수행하고 최종 처리에서는 **반복, 카운팅, 평균, 총합 등의 집계 처리**를 수행한다.
- 다음 예제는 List에 저장되어 있는 Student 객체를 중간 처리에서 scroe 필드값으로 매핑하고, 최종 처리에서 score의 평균값을 산출한다.
```java
public class MapAndReduceExample {
    public static void main(String[] args) {
        List<Student> studentList = Arrays.asList(
                new Student("홍길동", 10),
                new Student("신용권", 20),
                new Student("유미선", 30)
        );
        
        double avg = studentList.stream()
                //중간 처리(학생 객체를 점수로 매핑)
                .mapToInt(Student :: getScore)
                //최종 처리(평균 점수)
                .average()
                .getAsDouble();

        System.out.println("평균 점수: " + avg);    //20.0
    }
}
```

# 2. 스트림의 종류
- 자바 8부터 새로 추가된 java.util.stream 패키지에는 스트림 API들이 포진하고 있다.
- 패키지 내용을 보면 BaseStream 인터페이스를 부모로 해서 자식 인터페이스들이 상속 관계를 이루고 있다.

![스트림의 종류](https://user-images.githubusercontent.com/47477359/143688972-b4429665-09fa-4ded-a08f-f40b9f4a6fdb.png)
- BaseStream 인터페이스에는 모든 스트림에서 사용할 수 있는 공통 메소드들이 정의되어 있을 뿐 코드에서 직접적으로 사용되지는 않는다.
- Stream은 **객체 요소를 처리**하는 스트림이고, IntStream, LongStream, DoubleStream은 각각 기본 타입인 **int, long, double 요소를 처리**하는 스트림이다.
- 스트림 인터페이스의 구현 객체는 주로 컬렉션과 배열에서 얻지만, 다음과 같은 소스로부터 스트림 구현 객체를 얻을 수도 있다.

리턴 타입|메소드(매개 변수)|소스
:---|:---|:---
Stream\<T>|java.util.Collection.stream()<br>java.util.Collection.parallelStream()|컬렉션
Stream\<T><br>IntStream<br>LongStream<br>DoubleStream|Arrays.stream(T[]),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream.of(T[])<br>Arrays.stream(int[]),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IntStream.of(int[])<br>Arrays.stream(long[]),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LongStream.of(long[])<br>Arrays.stream(double[]),&nbsp;DoubleStream.of(double[])|배열
IntStream|IntStream.range(int, int)<br>IntStream.rangeClosed(int, int)|int 범위
LongStream|LongStream.range(long, long)<br>LongStream.rangeClosed(long, long)|long 범위
Stream\<Path>|Files.find(Path, int, BiPredicate, FileVisitOption)<br>Files.list(Path)|디렉토리
Stream\<String>|Files.lines(Path, Charset)<br>BufferedReader.lines()|파일
DoubleStream<br>IntStream<br>LongStream|Random.doubles()<br>Random.ints()<br>Random.longs()|랜덤 수

## 컬렉션으로부터 스트림 얻기
- 다음 예제는 List<Student> 컬렉션에서 Stream<Student>를 얻어내고 콘솔에 출력한다.
```java
public class  FromCollectionExample {
    public static void main(String[] args) {
        List<Student> studentList = Arrays.asList(
                new Student("홍길동", 10),
                new Student("신용권", 20),
                new Student("유미선", 30)
        );
        
        Stream<Student> stream = studentList.stream();
        stream.forEach(s -> System.out.println(s.getName));
    }
}
```

## 배열로부터 스트림 얻기
- 다음 예제는 String[]과 int[] 배열로부터 스트림을 얻어내고 콘솔에 출력한다.
```java
public class FromArrayExample {
    public static void main(String[] args) {
        String[] strings = { "홍길동", "신용권", "김자바" };
        Stream<String> stringStream = Arrays.stream(strings);
        stringStream.forEach(a -> System.out.println(a + ","));
        System.out.println();
        
        int[] ints = { 1, 2, 3, 4, 5 };
        IntStream intStream = Arrays.stream(ints);
        intStream.forEach(a -> System.out.println(a + ","));
    }
}
```

## 숫자 범위로부터 스트림 얻기
- 다음 예제는 1부터 100까지의 합을 구하기 위해 IntStream의 rangeClosed() 메소드를 이용하였다.
- rangeClosed()는 첫 번째 매개값에서부터 두 번째 매개값까지 순차적으로 제공하는 IntStream을 리턴한다.
- range() 메소드도 동일한 IntStream을 리턴하는데, 두 번째 매개값은 포함하지 않는다.
```java
public class FromIntRangeExample {
    public static int sum;

    public static void main(String[] args) {
        IntStream stream = IntStream.rangeClosed(1, 100);
        stream.forEach(a -> sum += a);
        System.out.println("총합: " + sum);
    }
}
```

## 파일로부터 스트림 얻기
- 다음 예제는 Files의 정적 메소드인 lines()와 BufferedReader의 lines() 메소드를 이용하여 문자 파일의 내용을 스트림을 통해 행 단위로 읽고 콘솔에 출력한다.
```java
public class FromFileContentExample {
    public static void main(String[] args) throws IOException {
        Path path = Paths.get("파/일/경/로.txt");
        Stream<String> stream;
        
        //Files.lines() 메소드 이용
        stream = Files.lines(path, Charset.defaultCharset());
        stream.forEach(System.out :: println);
        System.out.println();
        
        //BufferedReader의 lines() 메소드 이용
        File file = path.toFile();
        FileReader fileReader = new FileReader(file);
        BufferedReader br = new BufferedReader(fileReader);
        stream = br.lines();
        stream.forEach(System.out :: println);
    }
}
```

## 디렉토리로부터 스트림 얻기
- 다음 예제는 Files의 정적 메소드인 list()를 이용해서 디렉토리의 내용(서브 디렉토리 또는 파일 목록)을 스트림을 통해 읽고 콘솔에 출력한다.
```java
public class FromDirectoryExample {
    public static void main(String[] args) {
        Path path = Paths.get("C:/파일경로/source");
        Stream<Path> stream = Files.list(path);
        stream.forEach(p -> System.out.println(p.getFileName()));
    }
}
```

# 3. 스트림 파이프라인
- **대량의 데이터를 가공해서 축소하는 것**을 일반적으로 리덕션(Reduction)이라고 하는데, **데이터의 합계, 평균값, 카운팅, 최대값, 최소값** 등이 대표적인 리덕션의 결과물이라고 볼 수 있다.
- 그러나 컬렉션의 요소를 리덕션의 결과물로 바로 집계할 수 없을 경우에는 집계하기 좋도록 필터링, 매핑, 정렬, 그룹핑 등의 중간 처리가 필요하다.

## 중간 처리와 최종 처리
- 스트림은 데이터의 필터링, 매핑, 정렬, 그룹핑 등의 중간 처리와 합계, 평균, 카운팅, 최대값, 최소값 등의 최종 처리를 파이프라인(pipelines)으로 해결한다.
- 파이프라인은 **여러 개의 스트림이 연결되어 있는 구조**를 말한다.
- 파이프라인에서 최종 처리를 제외하고는 모두 중간 처리 스트림이다.

![파이프라인](https://user-images.githubusercontent.com/47477359/143765285-3fa452fc-fa81-4153-8606-f455f8af3ffc.png)
- 중간 스트림이 생성될 때 요소들이 바로 중간 처리되는 것이 아니라 최종 처리가 시작되기 전까지 지연(lazy)된다.
- 최종 처리가 시작되면 비로소 컬렉션의 요소가 하나씩 중간 스트림에서 처리되고 최종 처리까지 오게 된다.
- Stream 인터페이스에는 필터링, 매핑, 정렬 등의 많은 중간 처리 메소드가 있는데, 이 메소드들은 중간 처리된 스트림을 리턴한다.
- 그리고 이 스트림에서 다시 중간 처리 메소드를 호출해서 파이프라인을 형성하게 된다.

![파이프라인 예시](https://user-images.githubusercontent.com/47477359/143765400-113195dc-720c-4b5f-a138-63db62f0682f.png)
- 예를 들어 회원 컬렉션에서 남자만 필터링하는 중간 스트림을 연결하고, 다시 남자의 나이로 매핑하는 스트림을 연결한 후, 최종 남자 평균 나이를 집계했을 때 형성되는 파이프라인이다.

```java
public class StreamPipelinesExample {
    public static void main(String[] args) {
        List<Member> list = Arrays.asList(
                new Member("홍길동", Member.MALE, 30),
                new Member("김나리", Member.FEMALE, 20),
                new Member("신용권", Member.MALE, 45),
                new Member("박수미", Member.FEMALE, 27)
        );
        
        double ageAvg = list.stream()                       //오리지날 스트림
                .filter(m -> m.getGender() == Member.MALE)  //중간 처리 스트림
                .mapToInt(Member :: getAge)                 //중간 처리 스트림
                .average()                                  //최종 처리
                .getAsDouble();

        System.out.println("남자 평균 나이: " +ageAvg);
    }
}
```

## 중간 처리 메소드와 최종 처리 메소드

<table>
<tr><th colspan="2">종류</th><th>리턴 타입</th><th>메소드(매개 변수)</th><th>소속된 인터페이스</th></tr>
<tr><td rowspan="16">중간 처리</td><td rowspan="2">필터링</td><td rowspan="16">Stream<br>IntStream<br>LongStream<br>DoubleStream</td><td>distinct()</td><td>공통</td></tr>
<tr><td>filter(...)</td><td>공통</td></tr>
<tr><td rowspan="12">매핑</td><td>flatMap(...)</td><td>공통</td></tr>
<tr><td>flatMapToDouble(...)</td><td>Stream</td></tr>
<tr><td>flatMapToInt(...)</td><td>Stream</td></tr>
<tr><td>flatMapToLong(...)</td><td>Stream</td></tr>
<tr><td>map(...)</td><td>공통</td></tr>
<tr><td>mapToDouble(...)</td><td>Stream, IntStream, LongStream</td></tr>
<tr><td>mapToInt(...)</td><td>Stream, LongStream, DoubleStream</td></tr>
<tr><td>mapToLong(...)</td><td>Stream, IntStream, DoubleStream</td></tr>
<tr><td>mapToObj(...)</td><td>IntStream, LongStream, DoubleStream</td></tr>
<tr><td>asDoubleStream()</td><td>IntStream, LongStream</td></tr>
<tr><td>asLongStream()</td><td>IntStream</td></tr>
<tr><td>boxed()</td><td>IntStream, LongStream, DoubleStream</td></tr>
<tr><td>정렬</td><td>sorted(...)</td><td>공통</td></tr>
<tr><td>루핑</td><td>peek(...)</td><td>공통</td></tr>

<tr><td rowspan="12">최종 처리</td><td rowspan="3">매칭</td><td>boolean</td><td>allMatch(...)</td><td>공통</td></tr>
<tr><td>boolean</td><td>anyMatch(...)</td><td>공통</td></tr>
<tr><td>boolean</td><td>noneMatch(...)</td><td>공통</td></tr>
<tr><td rowspan="7">집계</td><td>long</td><td>count()</td><td>공통</td></tr>
<tr><td>OptionalXXX</td><td>findFirst()</td><td>공통</td></tr>
<tr><td>OptionalXXX</td><td>max(...)</td><td>공통</td></tr>
<tr><td>OptionalXXX</td><td>min(...)</td><td>공통</td></tr>
<tr><td>OptionalDouble</td><td>average()</td><td>IntStream, LongStream, DoubleStream</td></tr>
<tr><td>OptionalXXX</td><td>reduce(...)</td><td>공통</td></tr>
<tr><td>int, long, double</td><td>sum()</td><td>IntStream, LongStream, DoubleStream</td></tr>
<tr><td>루핑</td><td>void</td><td>forEach(...)</td><td>공통</td></tr>
<tr><td>수집</td><td>R</td><td>collect(...)</td><td>공통</td></tr>
</table>

- 중간 처리 메소드와 최종 처리 메소드를 쉽게 구분하는 방법은 리턴 타입을 보면 된다.
- 리턴 타입이 **스트림**이라면 중간 처리 메소드이고, **기본 타입이거나 OptionalXXX**라면 최종 처리 메소드이다.
- 소속된 인터페이스에서 공통의 의미는 Stream, IntStream, LongStream, DoubleStream에서 모두 제공된다는 뜻이다.

# 4. 필터링(distinct(), filter())
- 필터링은 중간 처리 기능으로 **요소를 걸러내는 역할**을 한다.
- 필터링 메소드인 distinct(), filter() 메소드는 모든 스트림이 가지고 있는 공통 메소드이다.

<table>
<tr><th>리턴 타입</th><th>메소드(매개 변수)</th><th>설명</th></tr>
<tr><td rowspan="5">Stream<br>IntStream<br>LongStream<br>DoubleStream</td><td>distinct()</td><td>중복 제거</td></tr>
<tr><td>filter(Predicate)</td><td rowspan="4">조건 필터링</td></tr>
<tr><td>filter(IntPredicate)</td></tr>
<tr><td>filter(LongPredicate)</td></tr>
<tr><td>filter(DoublePredicate)</td></tr>
</table>

- distinct() 메소드는 중복을 제거하는데, Stream의 경우 **Object.equals(Object)가 true이면 동일한 객체로 판단**하고 중복을 제거한다.
- IntStream, LongStream, DoubleStream은 **동일값일 경우** 중복을 제거한다.

![distinct()](https://user-images.githubusercontent.com/47477359/143767178-817aef06-2c5b-4336-b6be-991fba492501.png)

- filter() 메소드는 매개값으로 주어진 **Predicate가 true를 리턴하는 요소**만 필터링한다.

![filter()](https://user-images.githubusercontent.com/47477359/143767196-784252d1-38f2-43ec-b6e4-c6aebe951227.png)

```java
public class FilteringExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList(
                "홍길동", "신용권", "김자바",
                "신용권", "신민철"
        );
        
        names.stream()
                .distinct()                             //중복 제거
                .forEach(n -> System.out.print(n + " "));
        
        names.stream()
                .filter(n -> n.startWith("신"))         //필터링
                .forEach(n -> System.out.print(n + " "));
        
        names.stream()
                .distinct()                             //중복 제거 후 필터링
                .filter(n -> n.startWith("신"))
                .forEach(n -> System.out.print(n + " "));
    }
}

<실행 결과>
홍길동 신용권 김자바 신민철
신용권 신용권 신민철
신용권 신민철
```

# 5. 매핑(flatMapXXX(), mapXXX(), asXXXStream(), boxed())
- 매핑은 중간 처리 기능으로 **스트림의 요소를 다른 요소로 대체하는 작업**을 말한다.

## flatMapXXX() 메소드
- flatMapXXX() 메소드는 **요소를 대체하는 복수 개의 요소들로 구성된 새로운 스트림을 리턴**한다.
- 스트림에서 A라는 요소는 A1, A2 요소로 대체되고, B라는 요소는 B1, B2로 대체된다고 가정했을 경우, A1, A2, B1, B2 요소를 가지는 새로운 스트림이 생성된다.

![flatMapXXX()](https://user-images.githubusercontent.com/47477359/143868945-f05eb3b9-aeb5-486d-a5ca-f5b171ff32d0.png)

리턴 타입|메소드(매개 변수)|요소 -> 대체 요소
:---|:---|:---
Stream<R>|flatMap(Function\<T, Stream\<R>>)|T -> Stream\<R>
DoubleStream|flatMap(DoubleFunction\<DoubleStream>)|double -> DoubleStream
IntStream|flatMap(IntFunction\<IntStream>)|int -> IntStream
LongStream|flatMap(LongFunction\<LongStream>)|long -> LongStream
DoubleStream|flatMapToDouble(Function\<T, DoubleStream>)|T -> DoubleStream
IntStream|flatMapToInt(Function\<T, IntStream>)|T -> IntStream
LongStream|flatMapToLong(Function\<T, LongStream>)|T -> LongStream

```java
public class FlatMapExample {
    public static void main(String[] args) {
        List<String> inputList1 = Arrays.asList("java8 lambda", "stream mapping");
        inputList1.stream()
                .flatMap(data -> Arrays.stream(data.split(" ")))
                .forEach(word -> System.out.println(word));

        System.out.println();
        
        List<String> inputList2 = Arrays.asList("10, 20, 30", "40, 50, 60");
        inputList2.stream
                .flatMapToInt(data -> {
                    String[] strArr = data.split(",");
                    int[] intArr = new int[strArr.length];
                    for (int i = 0; i < strArr.length; i++) {
                        intArr[i] = Integer.parseIng(strArr[i].trim());
                    }
                    return Arrays.stream(intArr);
                })
                .forEach(number -> System.out.println(number));
    }
}

실행 결과
java8
lambda
stream
mapping

10
20
30
40
50
60
```

## mapXXX() 메소드
- mapXXX() 메소드는 **요소를 대체하는 요소로 구성된 새로운 스트림을 리턴**한다.
- 스트림에서 A 요소는 C 요소로 대체되고, B 요소는 D 요소로 대체된다고 했을 경우, C, D 요소를 가지는 새로운 스트림이 생성된다.

![mapXXX()](https://user-images.githubusercontent.com/47477359/143870871-2c76ae40-23cc-4494-a35a-4914eff8942e.png)

리턴 타입|메소드(매개 변수)|요소 -> 대체 요소
:---|:---|:---
Stream\<R>|map(Function\<T, R>)|T -> R
DoubleStream|mapToDouble(ToDoubleFunction\<T>)|T -> double
IntStream|mapToInt(ToIntFunction\<T>)|T -> int
LongStream|mapToLong(ToLongFunction\<T>)|T -> long
DoubleStream|map(DoubleUnaryOperator)|double -> double
IntStream|mapToInt(DoubleToIntFunction)|double -> int
LongStream|mapToLong(DoubleToLongFunction)|double -> long
Stream\<U>|mapToObj(DoubleFunction\<U>)|double -> U
IntStream|map(IntUnaryOperator)|int -> int
DoubleStream|mapToDouble(IntToDoubleFunction)|int -> double
LongStream|mapToLong(IntToLongFunction)|int -> long
Stream\<U>|mapToObj(IntFunction\<U>)|int -> U
LongStream|map(LongUnaryOperator)|long -> long
DoubleStream|mapToDouble(LongToDoubleFunction)|long -> double
IntStream|mapToInt(LongToIntFunction)|long -> int
Stream\<U>|mapToObj(LongFunction\<U>)|long -> U

```java
public class MapExample {
    public static void main(String[] args) {
        List<Student> studentList = Arrays.asList(
                new Student("홍길동", 10),
                new Student("신용권", 20),
                new Student("유미선", 30)
        );
        
        studentList.stream()
                .mapToInt(Student :: getScore)
                .forEach(score -> System.out.println(score));
    }
}

실행 결과
10
20
30
```

## asDoubleStream(), asLongStream(), boxed() 메소드
- asDoubleStream() 메소드는 IntStream의 int 요소 또는 LongStream의 long 요소를 **double 요소로 타입 변환해서 DoubleStream을 생성**한다.
- asLongStream() 메소드는 IntStream의 int 요소를 **long 요소로 타입 변환해서 LongStream을 생성**한다.
- boxed() 메소드는 **int, long, double 요소를 Integer, Long, Double 요소로 박싱해서 Stream을 생성**한다.

리턴 타입|메소드(매개 변수)|설명
:---|:---|:---
DoubleStream|asDoubleStream()|int -> double<br>long -> double
LongStream|asLongStream()|int -> long
Stream\<Integer><br>Stream\<Long><br>Stream\<Double>|boxed()|int -> Integer<br>long -> Long<br>double -> Double

```java
public class AsDoubleStreamAndBoxedExample {
    public static void main(String[] args) {
        int[] intArray = { 1, 2, 3, 4, 5 };
        
        IntStream intStream = Arrays.stream(intArray);
        intStream
                .asDoubleStream()
                .forEach(d -> System.out.println(d));

        System.out.println();
        
        intStream = Arrays.stream(intArray);
        intStream
                .boxed()
                .forEach(obj -> System.out.println(obj.intValue()));
    }
}

실행 결과
1.0
2.0
3.0
4.0
5.0

1
2
3
4
5
```

# 6. 정렬(sorted())
- 스트림은 요소가 최종 처리되기 전에 중간 단계에서 요소를 정렬해서 최종 처리 순서를 변경할 수 있다.

리턴 타입|메소드(매개 변수)|설명
:---|:---|:---
Stream\<T>|sorted()|객체를 Comparable 구현 방법에 따라 정렬
Stream\<T>|sorted(Comparator\<T>)|객체를 주어진 Comparator에 따라 정렬
DoubleStream|sorted()|double 요소를 오름차순으로 정렬
IntStream|sorted()|int 요소를 오름차순으로 정렬
LongStream|sorted()|long 요소를 오름차순으로 정렬

- 객체 요소일 경우에는 클래스가 Comparable을 구현하지 않으면 sorted() 메소드를 호출했을 때 ClassCastException이 발생하기 때문에 Comparable을 구현한 요소에서만 sorted() 메소드를 호출해야 한다.

```java
public class Student implements Comparable<Student> {
    private String name;
    private int score;

    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public int getScore() {
        return score;
    }
    
    @Override
    public int CompareTo(Student o) {
        return Integer.compare(score, o.score);
    }
}
```

- 객체 요소가 Comparable을 구현한 상태에서 기본 비교(Comparable) 방법으로 정렬하고 싶다면 다음 세 가지 방법 중 하나를 선택해서 sorted()를 호출하면 된다.
```java
sorted();
sorted( (a, b) -> a.compareTo(B) );
sorted( Comparator.naturalOrder() );
```

- 만약 객체 요소가 Comparable을 구현하고 있지만, 기본 비교 방법과 정반대 방법으로 정렬하고 싶다면 다음과 같이 sorted()를 호출하면 된다.
```java
sorted( (a, b) -> b.compareTo(a) );
sorted( Comparator.reverseOrder() );
```

- 객체 요소가 Comparable을 구현하지 않았다면 Comparator를 매개값으로 갖는 sorted() 메소드를 사용하면 된다.
- Comparator는 함수적 인터페이스이므로 람다식으로 매개값을 작성할 수 있다.
```java
sorted( (a, b) -> { ... } );
```
- 중괄호 {} 안에는 a와 b를 비교해서 a가 작으면 음수, 같으면 0, a가 크면 양수를 리턴하는 코드를 작성하면 된다.
```java
public class  SortingExample {
    public static void main(String[] args) {
        //숫자 요소일 경우
        IntStream intStream = Arrays.stream(new int[] { 5, 3, 2, 1, 4});
        intStream
            .sorted()
            .firEach(n -> System.out.println(n + ","));
		System.out.println();
        
		//객체 요소일 경우
        List<Student> studentList = Arrays.asList(
        	new Student("홍길동", 30),
            new Student("신용권", 10),
            new Student("유미선", 20)
        );
        
        studentList.stream()
            .sorted()
            .forEach(s -> System.out.println(s.getScore() + ","));
		System.out.println();
        
		studentList.stream()
            .sorted(Comparator.reverseOrder())
            .forEach(s -> System.out.println(s.getScore() + ","));
    }
}

실행 결과
1, 2, 3, 4, 5,
10, 20, 30,
30, 20, 10,
```

# 7. 루핑(peek(), forEach())
- 루핑은 **요소 전체를 반복하는 것**을 말한다.
- peek()는 **중간 처리 단계**에서 전체 요소를 루핑하면서 추가적인 작업을 하기 위해 사용한다.
- 최종 처리 메소드가 실행되지 않으면 지연되기 때문에 반드시 최종 처리 메소드가 호출되어야 동작한다.
- forEach()는 **최종 처리 메소드**이기 때문에 파이프라인 마지막에 루핑하면서 요소를 하나씩 처리한다.
```java
public class LoopingExample {
	public static void main(String[] args) {
        int[] intArr = { 1, 2, 3, 4, 5 };

		System.out.println("[peek()를 마지막에 호출한 경우]");
        Arrays.stream(intArr)
            .filter(a -> a % 2 == 0)
            .peek(n -> System.out.println(n));      //동작하지 않음

		System.out.println("[최종 처리 메소드를 마지막에 호출한 경우]");
        int total = Arrays.stream(intArr)
            .filter(a -> a % 2 == 0)
            .peek(n -> System.out.println(n))       //동작함
            .sum();                                 //최종 메소드
		System.out.println("총합: " + total);

		System.out.println("[forEach()를 마지막에 호출한 경우]");
        Arrays.stream(intArr)
            .filter(a -> a % 2 == 0)
            .forEach(n -> System.out.println(n));   //최종 메소드로 동작함
	}
}

실행 결과
[peek()를 마지막에 호출한 경우]
[최종 처리 메소드를 마지막에 호출한 경우]
2
4
총합: 6
[forEach()를 마지막에 호출한 경우]
2
4
```

# 8. 매칭(allMatch(), anyMatch(), noneMatch())
- 스트림 클래스는 최종 처리 단계에서 요소들이 특정 조건에 만족하는지 조사할 수 있도록 세 가지 매칭 메소드를 제공하고 있다.
- allMatch() 메소드는 모든 요소들이 매개값으로 주어진 Predicate의 조건을 만족하는지 조사한다.
- anyMatch() 메소드는 최소한 한 개의 요소가 매개값으로 주어진 Predicate의 조건을 만족하는지 조사한다.
- noneMatch() 메소드는 모든 요소들이 매개값으로 주어진 Predicate의 조건을 만족하지 않는지 조사한다.

리턴 타입|메소드(매개 변수)|제공 인터페이스
:---|:---|:---
boolean|allMatch(Predicate\<T> predicate)<br>anyMatch(Predicate\<T> predicate)<br>noneMatch(Predicate\<T> predicate)|Stream
boolean|allMatch(IntPredicate predicate)<br>anyMatch(IntPredicate predicate)<br>noneMatch(IntPredicate predicate)|IntStream
boolean|allMatch(LongPredicate predicate)<br>anyMatch(LongPredicate predicate)<br>noneMatch(LongPredicate predicate)|LongStream
boolean|allMatch(DoublePredicate predicate)<br>anyMatch(DoublePredicate predicate)<br>noneMatch(DoublePredicate predicate)|DoubleStream

```java
public class MatchExample {
	public static void main(String[] args) {
        int[] intArr = { 2, 4, 6 };
        
        boolean result = Arrays.stream(intArr)
            .allMatch(a -> a % 2 == 0);
		System.out.println("모두 2의 배수인가? " + result);
        
		result = Arrays.stream(intArr)
            .anyMatch(a -> a % 3 == 0);
		System.out.println("하나라도 3의 배수가 있는가? " + result);
        
		result = Arrays.stream(intArr)
            .noneMatch(a -> a % 3 == 0);
		System.out.println("3의 배수가 없는가? " + result);
	}
}
```

# 9. 기본 집계(sum(), count(), average(), max(), min())

- 집계(Aggregate)는 최종 처리 기능으로 **요소들을 처리**해서 카운팅, 합계, 평균값, 최대값, 최소값 등과 같이 **하나의 값으로 산출하는 것**을 말한다.
- 집계는 대량의 데이터를 가공해서 축소하는 리덕션(Reduction)이라고 볼 수 있다.

## 스트림이 제공하는 기본 집계

리턴 타입|메소드(매개 변수)|설명
:---|:---|:---
long|count()|요소 개수
OptionalXXX|findFirst()|첫 번째 요소
Optional\<T><br>OptionalXXX|max(Comparator\<T>)<br>max()|최대 요소
Optional\<T><br>OptionalXXX|min(Comparator\<T>)<br>min()|최소 요소
OptionalDouble|average()|요소 평균
int, long, double|sum()|요소 총합

- 집계 메소드에서 리턴하는 OptionalXXX는 자바 8에서 추가한 java.util 패키지의 Optional, OptionalDouble, OptionalInt, OptionalLong 클래스 타입을 말한다.  
- 이들은 값을 저장하는 **값 기반 클래스**(value-based class)들이다.
- 이 객체에서 값을 얻기 위해서는 get(), getAsDouble(), getAsInt(), getAsLong()을 호출하면 된다.

```java
public class AggregateExample { 
	public static void main(String[] args) { 
		long count = Arrays.stream(new int[] {1, 2, 3, 4, 5})
            .filter(n -> n % 2 == 0)
            .count();
		System.out.println("2의 배수 개수: " + count);
        
		long sum = Arrays.stream(new int[] {1, 2, 3, 4, 5})
            .filter(n -> n % 2 == 0)
            .sum();
		System.out.println("2의 배수의 합: " + sum);
        
		double avg = Arrays.stream(new int[] {1, 2, 3, 4, 5})
            .filter(n -> n % 2 == 0)
            .average()
            .getAsDouble();
		System.out.println("2의 배수의 평균: " + avg);
        
		int max = Arrays.stream(new int[] {1, 2, 3, 4, 5})
            .filter(n -> n % 2 == 0)
            .max()
            .getAsInt();
		System.out.println("최대값: " + max);
        
		int max = Arrays.stream(new int[] {1, 2, 3, 4, 5})
            .filter(n -> n % 2 == 0)
            .min()
            .getAsInt();
		System.out.println("최소값: " + min);
        
		int first = Arrays.stream(new int[] {1, 2, 3, 4, 5})
            .filter(n -> n % 2 == 0)
            .findFirst()
            .getAsInt();
		System.out.println("첫 번째 2의 배수: " + first);
	}
}
```

## Optional 클래스

- Optional 클래스는 단순히 집계 값만 저장하는 것이 아니라, 집계 값이 존재하지 않을 경우 **디폴트 값을 설정**할 수도 있고, 집계 값을 처리하는 Consumer도 등록할 수 있다.

리턴 타입|메소드(매개 변수)|설명
:---|:---|:---
boolean|isPresent()|값이 저장되어 있는지 여부
T<br>double<br>int<br>long|orElse(T)<br>orElse(double)<br>orElse(int)<br>orElse(long)|값이 저장되어 있지 않을 경우 디폴트 값 지정
void|ifPresent(Consumer)<br>ifPresent(DoubleConsumer)<br>ifPresent(IntConsumer)<br>ifPresent(LongConsumer)|값이 저장되어 있을 경우 Consumer에서 처리

- 컬렉션의 요소는 동적으로 추가되는 경우가 많다.
- 만약 컬렉션의 요소가 추가되지 않아 저장된 요소가 없을 경우 다음 코드는 어떻게 될까?
```java
List<Integer> list = new ArrayList<>();
double avg = list.stream()
    .mapToInt(Integer :: intValue)
    .average()
    .getAsDouble();
System.out.println("평균: " + avg);
```

- 요소가 없기 때문에 평균값도 있을 수 없고, 따라서 NoSuchElementException 예외가 발생한다.
- 요소가 없을 경우 예외를 피하는 세 가지 방법이 있는데, 첫 번째는 Optional 객체를 얻어 **isPresent() 메소드로 평균값 여부를 확인**하는 것이다.
```java
OptionalDouble optional = list.stream()
    .mapToInt(Integer :: intValue)
    .average();

if (optional.isPresent()) {
	System.out.println("평균: " + optional.getAsDouble());
} else {
	System.out.println("평균: 0.0");
}
```

- 두 번째 방법은 **orElse() 메소드로 디폴트 값**을 정해 놓는다.
```java
double avg = list.stream()
    .mapToInt(Integer :: intValue)
    .average()
    .orElse(0.0);
```

- 세 번째 방법은 **ifPresent() 메소드로 평균값이 있을 경우에만 값을 이용**하는 람다식을 실행한다.
```java
list.stream()
    .mapToInt(Integer :: intValue)
    .average()
    .ifPresent(a -> System.out.println("평균: " + a));
```
